"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isReceiverReady = exports.storageDeposit = exports.processNearFungiblePayment = exports.processNearPaymentWithConversion = exports.processNearPayment = exports.isNearAccountSolvent = exports.isValidNearAddress = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const near_api_js_1 = require("near-api-js");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/types");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const isValidNearAddress = (nearNetwork, address) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    try {
        yield nearNetwork.connection.provider.query(`account/${address}`, '');
        return true;
    }
    catch (e) {
        return false;
    }
});
exports.isValidNearAddress = isValidNearAddress;
const isNearAccountSolvent = (amount, nearWalletConnection, token) => {
    if (!token || token.type === types_1.RequestLogicTypes.CURRENCY.ETH) {
        return nearWalletConnection
            .account()
            .state()
            .then((state) => {
            var _a;
            const balance = ethers_1.BigNumber.from((_a = state === null || state === void 0 ? void 0 : state.amount) !== null && _a !== void 0 ? _a : '0');
            return balance.gte(amount);
        });
    }
    if (token.type === types_1.RequestLogicTypes.CURRENCY.ERC20) {
        const fungibleContract = new near_api_js_1.Contract(nearWalletConnection.account(), token.value, {
            changeMethods: [],
            viewMethods: ['ft_balance_of'],
        });
        return fungibleContract
            .ft_balance_of({
            account_id: nearWalletConnection.account().accountId,
        })
            .then((balance) => ethers_1.BigNumber.from(balance).gte(amount));
    }
    throw new Error(`isNearAccountSolvent not implemented for ${token.type}`);
};
exports.isNearAccountSolvent = isNearAccountSolvent;
const GAS_LIMIT_IN_TGAS = 50;
const GAS_LIMIT = ethers_1.ethers.utils.parseUnits(GAS_LIMIT_IN_TGAS.toString(), 12);
const GAS_LIMIT_NATIVE = GAS_LIMIT.toString();
const GAS_LIMIT_CONVERSION_TO_NATIVE = GAS_LIMIT.mul(2).toString(); // 200 TGas
const GAS_LIMIT_FUNGIBLE_PROXY = GAS_LIMIT.mul(4).toString(); // 400 TGas
const processNearPayment = (walletConnection, network, amount, to, paymentReference, version = '0.2.0', callback = undefined) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (version !== '0.2.0') {
        if (version === '0.1.0') {
            throw new Error('Native Token payments on Near with extension v0.1.0 are not supported anymore');
        }
        throw new Error('Native Token payments on Near only support v0.2.0 extensions');
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, to))) {
        throw new Error(`Invalid NEAR payment address: ${to}`);
    }
    try {
        const contract = new near_api_js_1.Contract(walletConnection.account(), payment_detection_1.NearNativeTokenPaymentDetector.getContractName(network, version), {
            changeMethods: ['transfer_with_reference'],
            viewMethods: [],
        });
        yield contract.transfer_with_reference(Object.assign({ args: {
                to,
                payment_reference: paymentReference,
            }, gas: GAS_LIMIT_NATIVE, amount: amount.toString() }, callback));
        return;
    }
    catch (e) {
        throw new Error(`Could not pay Near request. Got ${e.message}`);
    }
});
exports.processNearPayment = processNearPayment;
/**
 * Processes a payment in Near native token, with conversion.
 *
 * @param amount is defined with 2 decimals, denominated in `currency`
 * @param currency is a currency ticker (e.g. "ETH" or "USD")
 * @param maxRateTimespan accepts any kind rate's age if '0'
 */
const processNearPaymentWithConversion = (walletConnection, network, amount, to, paymentReference, currency, feeAddress, feeAmount, maxToSpend, maxRateTimespan = '0', version = '0.1.0', callback = undefined) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (version !== '0.1.0') {
        throw new Error('Native Token with conversion payments on Near only support v0.1.0 extensions');
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, to))) {
        throw new Error(`Invalid NEAR payment address: ${to}`);
    }
    if (!(yield (0, exports.isValidNearAddress)(walletConnection._near, feeAddress))) {
        throw new Error(`Invalid NEAR fee address: ${feeAddress}`);
    }
    try {
        const contract = new near_api_js_1.Contract(walletConnection.account(), payment_detection_1.NearConversionNativeTokenPaymentDetector.getContractName(network, version), {
            changeMethods: ['transfer_with_reference'],
            viewMethods: [],
        });
        yield contract.transfer_with_reference(Object.assign({ args: {
                payment_reference: paymentReference,
                to,
                amount,
                currency,
                fee_address: feeAddress,
                fee_amount: feeAmount,
                max_rate_timespan: maxRateTimespan,
            }, gas: GAS_LIMIT_CONVERSION_TO_NATIVE, amount: maxToSpend.toString() }, callback));
        return;
    }
    catch (e) {
        throw new Error(`Could not pay Near request. Got ${e.message}`);
    }
});
exports.processNearPaymentWithConversion = processNearPaymentWithConversion;
const processNearFungiblePayment = (walletConnection, network, amount, to, paymentReference, currencyAddress, feeAddress, feeAmount, callback = undefined) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const fungibleContract = new near_api_js_1.Contract(walletConnection.account(), currencyAddress, {
        changeMethods: ['ft_transfer_call'],
        viewMethods: [],
    });
    const proxyAddress = smart_contracts_1.erc20FeeProxyArtifact.getAddress(network, 'near');
    yield fungibleContract.ft_transfer_call(Object.assign({ args: {
            receiver_id: proxyAddress,
            amount: ethers_1.BigNumber.from(amount).add(feeAmount).toString(),
            msg: JSON.stringify({
                fee_address: feeAddress,
                fee_amount: feeAmount,
                payment_reference: paymentReference,
                to,
            }),
        }, gas: GAS_LIMIT_FUNGIBLE_PROXY, amount: '1'.toString() }, callback));
});
exports.processNearFungiblePayment = processNearFungiblePayment;
// min. 0.00125 â“ƒ
const MIN_STORAGE_FOR_FUNGIBLE = '1250000000000000000000';
/**
 * Stores the minimum deposit amount on the `paymentAddress` account for `tokenAddress`.
 * This does not check the existing deposit, if any, and should be called if `isReceiverReady` is false.
 * @param walletConnection
 * @param tokenAddress
 * @param paymentAddress
 */
const storageDeposit = (walletConnection, tokenAddress, paymentAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const fungibleContract = new near_api_js_1.Contract(walletConnection.account(), tokenAddress, {
        changeMethods: ['storage_deposit'],
        viewMethods: [],
    });
    yield fungibleContract.storage_deposit({
        args: { account_id: paymentAddress },
        value: MIN_STORAGE_FOR_FUNGIBLE,
    });
});
exports.storageDeposit = storageDeposit;
/**
 * This checks that the `paymentAddress` has enough storage on the `tokenAddress` to receive tokens.
 *
 * It returns false if trying to send tokens to the `paymentAddress` would result in:
 *
 * - 'Smart contract panicked: The account account.identifier.near is not registered'
 *
 */
const isReceiverReady = (walletConnection, tokenAddress, paymentAddress) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const fungibleContract = new near_api_js_1.Contract(walletConnection.account(), tokenAddress, {
        changeMethods: [],
        viewMethods: ['storage_balance_of'],
    });
    const storage = (yield fungibleContract.storage_balance_of({
        account_id: paymentAddress,
    }));
    return !!storage && ethers_1.BigNumber.from(storage === null || storage === void 0 ? void 0 : storage.total).gte(MIN_STORAGE_FOR_FUNGIBLE);
});
exports.isReceiverReady = isReceiverReady;
//# sourceMappingURL=utils-near.js.map