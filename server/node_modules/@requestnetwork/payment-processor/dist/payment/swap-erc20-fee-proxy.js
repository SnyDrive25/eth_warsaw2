"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeSwapToPayErc20FeeRequest = exports.prepareSwapToPayErc20FeeRequest = exports.swapErc20FeeProxyRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const smart_contracts_1 = require("@requestnetwork/smart-contracts");
const types_1 = require("@requestnetwork/smart-contracts/types");
const utils_1 = require("./utils");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const currency_1 = require("@requestnetwork/currency");
/**
 * Processes a transaction to swap tokens and pay an ERC20 Request through a proxy with fees.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param swapSettings settings for the swap: swap path, max amount to swap, deadline
 * @param options to override amount, feeAmount and transaction parameters
 */
function swapErc20FeeProxyRequest(request, signerOrProvider = (0, utils_1.getProvider)(), swapSettings, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const preparedTx = prepareSwapToPayErc20FeeRequest(request, signerOrProvider, swapSettings, options);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        const tx = yield signer.sendTransaction(preparedTx);
        return tx;
    });
}
exports.swapErc20FeeProxyRequest = swapErc20FeeProxyRequest;
/**
 * Prepare a transaction to swap tokens and pay an ERC20 Request through a proxy with fees.
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param swapSettings settings for the swap: swap path, max amount to swap, deadline
 * @param options to override amount, feeAmount and transaction parameters
 */
function prepareSwapToPayErc20FeeRequest(request, signerOrProvider = (0, utils_1.getProvider)(), swapSettings, options) {
    const { network } = request.currencyInfo;
    currency_1.EvmChains.assertChainSupported(network);
    const encodedTx = encodeSwapToPayErc20FeeRequest(request, signerOrProvider, swapSettings, options);
    const proxyAddress = smart_contracts_1.erc20SwapToPayArtifact.getAddress(network);
    return Object.assign({ data: encodedTx, to: proxyAddress, value: 0 }, options === null || options === void 0 ? void 0 : options.overrides);
}
exports.prepareSwapToPayErc20FeeRequest = prepareSwapToPayErc20FeeRequest;
/**
 * Encodes the call to pay a request through the ERC20 fee proxy contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum
 * @param swapSettings settings for the swap
 * @param options to override amount, feeAmount and transaction parameters
 */
function encodeSwapToPayErc20FeeRequest(request, signerOrProvider = (0, utils_1.getProvider)(), swapSettings, options) {
    const { paymentReference, paymentAddress, feeAddress, feeAmount, network } = (0, utils_1.getRequestPaymentValues)(request);
    currency_1.EvmChains.assertChainSupported(network);
    (0, utils_1.validateErc20FeeProxyRequest)(request, options === null || options === void 0 ? void 0 : options.amount, options === null || options === void 0 ? void 0 : options.feeAmount);
    const signer = (0, utils_1.getSigner)(signerOrProvider);
    const tokenAddress = request.currencyInfo.value;
    const amountToPay = (0, utils_1.getAmountToPay)(request, options === null || options === void 0 ? void 0 : options.amount);
    const feeToPay = ethers_1.BigNumber.from((options === null || options === void 0 ? void 0 : options.feeAmount) || feeAmount || 0);
    if (swapSettings.path[swapSettings.path.length - 1].toLowerCase() !== tokenAddress.toLowerCase()) {
        throw new Error('Last item of the path should be the request currency');
    }
    // eslint-disable-next-line no-magic-numbers
    if (Date.now() > swapSettings.deadline * 1000) {
        throw new Error('A swap with a past deadline will fail, the transaction will not be pushed');
    }
    if (!request.currencyInfo.network) {
        throw new Error('Request currency network is missing');
    }
    const feeProxyAddress = (0, utils_1.getProxyAddress)(request, payment_detection_1.Erc20PaymentNetwork.ERC20FeeProxyPaymentDetector.getDeploymentInformation);
    const swapToPayAddress = smart_contracts_1.erc20FeeProxyArtifact.getAddress(network);
    const swapToPayContract = types_1.ERC20SwapToPay__factory.connect(swapToPayAddress, signer);
    return swapToPayContract.interface.encodeFunctionData('swapTransferWithReference', [
        feeProxyAddress,
        paymentAddress,
        amountToPay,
        swapSettings.maxInputAmount,
        swapSettings.path,
        `0x${paymentReference}`,
        feeToPay,
        feeAddress || ethers_1.constants.AddressZero,
        // eslint-disable-next-line no-magic-numbers
        Math.round(swapSettings.deadline / 1000),
    ]);
}
exports.encodeSwapToPayErc20FeeRequest = encodeSwapToPayErc20FeeRequest;
//# sourceMappingURL=swap-erc20-fee-proxy.js.map