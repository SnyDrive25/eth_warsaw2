"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodePayErc20TransferableReceivableRequest = exports.prepareErc20TransferableReceivablePaymentTransaction = exports.payErc20TransferableReceivableRequest = exports.encodeMintErc20TransferableReceivableRequest = exports.prepareMintErc20TransferableReceivableTransaction = exports.mintErc20TransferableReceivable = exports.hasReceivableForRequest = exports.getReceivableTokenIdForRequest = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const payment_detection_1 = require("@requestnetwork/payment-detection");
const types_1 = require("@requestnetwork/smart-contracts/types");
const utils_1 = require("./utils");
// The ERC20 receivable smart contract ABI fragment
const erc20TransferableReceivableContractAbiFragment = [
    'function receivableTokenIdMapping(bytes32) public view returns (uint256)',
];
/**
 * Gets the receivableTokenId from a ERC20TransferableReceivable contract given
 * a paymentReference and paymentAddress of the request
 * @param request
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
function getReceivableTokenIdForRequest(request, signerOrProvider) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // Setup the ERC20 proxy contract interface
        const contract = new ethers_1.ethers.Contract((0, utils_1.getProxyAddress)(request, payment_detection_1.ERC20TransferableReceivablePaymentDetector.getDeploymentInformation), erc20TransferableReceivableContractAbiFragment, signerOrProvider);
        const { paymentReference, paymentAddress } = (0, utils_1.getRequestPaymentValues)(request);
        return yield contract.receivableTokenIdMapping(ethers_1.ethers.utils.solidityKeccak256(['address', 'bytes'], [paymentAddress, `0x${paymentReference}`]));
    });
}
exports.getReceivableTokenIdForRequest = getReceivableTokenIdForRequest;
/**
 * Helper method to determine whether a request has a receivable minted yet
 *
 * @param request
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 */
function hasReceivableForRequest(request, signerOrProvider) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const receivableTokenId = yield getReceivableTokenIdForRequest(request, signerOrProvider);
        return !receivableTokenId.isZero();
    });
}
exports.hasReceivableForRequest = hasReceivableForRequest;
/**
 * Processes a transaction to mint an ERC20TransferableReceivable.
 * @param request
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param overrides optionally, override default transaction values, like gas.
 */
function mintErc20TransferableReceivable(request, signerOrProvider = (0, utils_1.getProvider)(), overrides) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { data, to, value } = prepareMintErc20TransferableReceivableTransaction(request);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.mintErc20TransferableReceivable = mintErc20TransferableReceivable;
/**
 * Encodes the call to mint a request through an ERC20TransferableReceivable contract, can be used with a Multisig contract.
 * @param request request to pay
 */
function prepareMintErc20TransferableReceivableTransaction(request) {
    (0, utils_1.validateERC20TransferableReceivable)(request);
    return {
        data: encodeMintErc20TransferableReceivableRequest(request),
        to: (0, utils_1.getProxyAddress)(request, payment_detection_1.Erc20PaymentNetwork.ERC20TransferableReceivablePaymentDetector.getDeploymentInformation),
        value: 0,
    };
}
exports.prepareMintErc20TransferableReceivableTransaction = prepareMintErc20TransferableReceivableTransaction;
/**
 * Encodes call to mint a request through an ERC20TransferableReceivable contract, can be used with a Multisig contract.
 * @param request request to pay
 */
function encodeMintErc20TransferableReceivableRequest(request) {
    (0, utils_1.validateERC20TransferableReceivable)(request);
    const tokenAddress = request.currencyInfo.value;
    const { paymentReference, paymentAddress } = (0, utils_1.getRequestPaymentValues)(request);
    const amount = (0, utils_1.getAmountToPay)(request);
    const receivableContract = types_1.ERC20TransferableReceivable__factory.createInterface();
    return receivableContract.encodeFunctionData('mint', [
        paymentAddress,
        `0x${paymentReference}`,
        amount,
        tokenAddress,
    ]);
}
exports.encodeMintErc20TransferableReceivableRequest = encodeMintErc20TransferableReceivableRequest;
/**
 * Processes a transaction to pay an ERC20 receivable Request.
 * @param request
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmount optionally, the fee amount to pay. Defaults to the fee amount of the request.
 * @param overrides optionally, override default transaction values, like gas.
 */
function payErc20TransferableReceivableRequest(request, signerOrProvider = (0, utils_1.getProvider)(), amount, feeAmount, overrides) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        yield (0, utils_1.validatePayERC20TransferableReceivable)(request, signerOrProvider, amount, feeAmount);
        const { data, to, value } = yield prepareErc20TransferableReceivablePaymentTransaction(request, signerOrProvider, amount, feeAmount);
        const signer = (0, utils_1.getSigner)(signerOrProvider);
        return signer.sendTransaction(Object.assign({ data, to, value }, overrides));
    });
}
exports.payErc20TransferableReceivableRequest = payErc20TransferableReceivableRequest;
/**
 * Encodes the call to pay a request through the ERC20 receivable contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function prepareErc20TransferableReceivablePaymentTransaction(request, signerOrProvider, amount, feeAmountOverride) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return {
            data: yield encodePayErc20TransferableReceivableRequest(request, signerOrProvider, amount, feeAmountOverride),
            to: (0, utils_1.getProxyAddress)(request, payment_detection_1.Erc20PaymentNetwork.ERC20TransferableReceivablePaymentDetector.getDeploymentInformation),
            value: 0,
        };
    });
}
exports.prepareErc20TransferableReceivablePaymentTransaction = prepareErc20TransferableReceivablePaymentTransaction;
/**
 * Encodes the call to pay a request through the ERC20 receivable contract, can be used with a Multisig contract.
 * @param request request to pay
 * @param signerOrProvider the Web3 provider, or signer. Defaults to window.ethereum.
 * @param amount optionally, the amount to pay. Defaults to remaining amount of the request.
 * @param feeAmountOverride optionally, the fee amount to pay. Defaults to the fee amount of the request.
 */
function encodePayErc20TransferableReceivableRequest(request, signerOrProvider, amount, feeAmountOverride) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const amountToPay = (0, utils_1.getAmountToPay)(request, amount);
        const { paymentReference, feeAddress, feeAmount } = (0, utils_1.getRequestPaymentValues)(request);
        const feeToPay = ethers_1.BigNumber.from(feeAmountOverride || feeAmount || 0);
        const receivableContract = types_1.ERC20TransferableReceivable__factory.createInterface();
        // get tokenId from request
        const receivableTokenId = yield getReceivableTokenIdForRequest(request, signerOrProvider);
        return receivableContract.encodeFunctionData('payOwner', [
            receivableTokenId,
            amountToPay,
            `0x${paymentReference}`,
            feeToPay,
            feeAddress || ethers_1.constants.AddressZero,
        ]);
    });
}
exports.encodePayErc20TransferableReceivableRequest = encodePayErc20TransferableReceivableRequest;
//# sourceMappingURL=erc20-transferable-receivable.js.map