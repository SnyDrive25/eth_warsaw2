"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const types_1 = require("@requestnetwork/types");
const utils_1 = require("@requestnetwork/utils");
const ethers_1 = require("ethers");
/**
 * Implementation of the web3 signature provider
 * Allows to sign() with "Ethereum_address" identities
 */
class Web3SignatureProvider {
    constructor(web3Provider) {
        /** list of supported signing method */
        this.supportedMethods = [types_1.SignatureTypes.METHOD.ECDSA_ETHEREUM];
        /** list of supported identity types */
        this.supportedIdentityTypes = [types_1.IdentityTypes.TYPE.ETHEREUM_ADDRESS];
        try {
            this.web3Provider = new ethers_1.providers.Web3Provider(web3Provider);
        }
        catch (error) {
            throw Error(`Can't initialize web3-eth ${error}`);
        }
    }
    /**
     * Signs data
     *
     * @param data The data to sign
     * @param signer The identity to sign with
     *
     * @returns The signed data
     */
    sign(data, signer) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.supportedIdentityTypes.includes(signer.type)) {
                throw Error(`Identity type not supported ${signer.type}`);
            }
            const normalizedData = (0, utils_1.normalize)(data);
            const signerEthers = this.web3Provider.getSigner(signer.value);
            let signatureValue;
            try {
                signatureValue = yield signerEthers.signMessage(Buffer.from(normalizedData));
            }
            catch (error) {
                // eslint-disable-next-line no-magic-numbers
                if (error.code === -32602) {
                    throw new Error(`Impossible to sign for the identity: ${signer.value}`);
                }
                throw error;
            }
            // some wallets (like Metamask) do a personal_sign (ECDSA_ETHEREUM),
            // some (like Trust) do a simple sign (ECDSA)
            const signedData = this.getSignedData(data, signatureValue, types_1.SignatureTypes.METHOD.ECDSA_ETHEREUM, signer) ||
                this.getSignedData(data, signatureValue, types_1.SignatureTypes.METHOD.ECDSA, signer);
            if (!signedData) {
                throw new Error('Signature failed!');
            }
            return signedData;
        });
    }
    /** Get the signed data, if valid, null if not */
    getSignedData(data, value, method, signer) {
        const signedData = {
            data,
            signature: {
                method,
                value,
            },
        };
        if ((0, utils_1.areEqualIdentities)((0, utils_1.recoverSigner)(signedData), signer)) {
            return signedData;
        }
        return null;
    }
}
exports.default = Web3SignatureProvider;
//# sourceMappingURL=web3-signature-provider.js.map